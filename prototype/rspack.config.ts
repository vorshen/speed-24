import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { defineConfig } from '@rspack/cli';
import { rspack } from '@rspack/core';
import fs from 'node:fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const isDev = process.env.NODE_ENV === 'development';

// 动态扫描 pages 目录
const pagesDir = path.resolve(__dirname, 'src/pages');

// 检查 pages 目录是否存在
if (!fs.existsSync(pagesDir)) {
  throw new Error(`Pages directory not found: ${pagesDir}`);
}

const pageFiles = fs
  .readdirSync(pagesDir)
  .filter((file) => file.endsWith('.tsx'))
  .map((file) => ({
    name: path.basename(file, '.tsx'),
    path: path.resolve(pagesDir, file),
  }));

if (pageFiles.length === 0) {
  throw new Error(`No .tsx files found in pages directory: ${pagesDir}`);
}

// 创建临时入口目录
const tempEntriesDir = path.resolve(__dirname, '.temp-entries');
if (!fs.existsSync(tempEntriesDir)) {
  fs.mkdirSync(tempEntriesDir, { recursive: true });
}

// 为每个页面创建包装入口文件
const entry = pageFiles.reduce(
  (acc, page) => {
    // 生成包装入口文件路径
    const wrapperPath = path.resolve(tempEntriesDir, `${page.name}.ts`);
    
    // 生成包装入口文件内容
    // 使用相对路径导入页面组件和 page-entry
    const pageRelativePath = path.relative(
      tempEntriesDir,
      page.path
    ).replace(/\\/g, '/'); // Windows 路径转 Unix 风格
    
    // 确保路径以 ./ 或 ../ 开头
    const normalizedPagePath = pageRelativePath.startsWith('.') 
      ? pageRelativePath 
      : `./${pageRelativePath}`;
    
    const wrapperContent = `// Auto-generated wrapper entry for ${page.name}
// This file is automatically generated by rspack.config.ts
import PageComponent from '${normalizedPagePath}';
import { initPage } from '../src/core/page-entry';

initPage(PageComponent);
`;

    // 写入包装文件
    fs.writeFileSync(wrapperPath, wrapperContent, 'utf-8');
    
    // 使用包装文件作为入口
    acc[page.name] = wrapperPath;
    return acc;
  },
  {} as Record<string, string>
);

// 生成 HTML 插件
const htmlPlugins = pageFiles.map(
  (page) => {
    const pageTitle = `${page.name.charAt(0).toUpperCase() + page.name.slice(1)} - App`;
    return new rspack.HtmlRspackPlugin({
      template: './src/template.html',
      filename: `${page.name}.html`,
      chunks: [page.name],
      inject: 'body',
      templateParameters: {
        title: pageTitle,
      },
      minify: !isDev, // Rspack 只支持布尔值
    });
  }
);

// 自定义插件：资源内联（生产环境）
class InlineAssetsPlugin {
  // @ts-ignore - Compiler is not defined in the rspack types
  apply(compiler: rspack.Compiler) {
    if (isDev) return; // 开发环境不内联

    compiler.hooks.afterEmit.tapAsync(
      'InlineAssetsPlugin',
      (compilation, callback) => {
        const outputPath =
          compilation.options.output?.path || path.resolve(__dirname, 'dist');

        // 等待文件写入完成
        setTimeout(() => {
          try {
            // 检查输出目录是否存在
            if (!fs.existsSync(outputPath)) {
              console.warn(
                `Output directory does not exist: ${outputPath}, skipping inline`
              );
              callback();
              return;
            }

            // 处理每个 HTML 文件
            const htmlFiles = fs
              .readdirSync(outputPath)
              .filter((f) => f.endsWith('.html'));

            // 读取 JSON 数据文件
            const dataDir = path.resolve(__dirname, 'src/data');
            let blueprintData = null;
            let storeData = null;
            let themeData = null;

            try {
              const blueprintPath = path.resolve(dataDir, 'blueprint.json');
              const storePath = path.resolve(dataDir, 'store.json');
              const themePath = path.resolve(dataDir, 'theme.json');

              if (fs.existsSync(blueprintPath)) {
                blueprintData = JSON.parse(
                  fs.readFileSync(blueprintPath, 'utf-8')
                );
              }
              if (fs.existsSync(storePath)) {
                storeData = JSON.parse(fs.readFileSync(storePath, 'utf-8'));
              }
              if (fs.existsSync(themePath)) {
                themeData = JSON.parse(fs.readFileSync(themePath, 'utf-8'));
              }
            } catch (error) {
              console.warn('Failed to load JSON data files:', error);
            }

            htmlFiles.forEach((htmlFile) => {
              const htmlPath = path.resolve(outputPath, htmlFile);
              let html = fs.readFileSync(htmlPath, 'utf-8');

              // 内联 JSON 数据到 HTML（Tailwind 已改为 PostCSS 构建，theme 由 tailwind.config 在构建时读取）
              if (blueprintData || storeData || themeData) {
                const jsonScript = `
  <script>
    window.__INLINE_DATA__ = {
      blueprint: ${JSON.stringify(blueprintData)},
      store: ${JSON.stringify(storeData)},
      theme: ${JSON.stringify(themeData)}
    };
  </script>`;

                if (html.includes('</head>')) {
                  html = html.replace('</head>', `${jsonScript}\n</head>`);
                } else if (html.includes('<body')) {
                  html = html.replace(/<body([^>]*)>/, `${jsonScript}\n<body$1>`);
                }
              }

              // 内联 JS 文件（排除 CDN 链接）
              html = html.replace(
                /<script[^>]*src="([^"]+\.js)"[^>]*><\/script>/gi,
                (match, src) => {
                  // 跳过 CDN 链接（http/https）
                  if (src.startsWith('http://') || src.startsWith('https://')) {
                    return match;
                  }

                  // 获取相对路径的 JS 文件
                  const jsPath = path.resolve(outputPath, src.replace(/^\//, ''));

                  if (fs.existsSync(jsPath)) {
                    const jsContent = fs.readFileSync(jsPath, 'utf-8');
                    return `<script>${jsContent}</script>`;
                  }

                  return match;
                }
              );

              // 内联 CSS 文件（排除 CDN 链接）
              html = html.replace(
                /<link[^>]*href="([^"]+\.css)"[^>]*>/gi,
                (match, href) => {
                  // 跳过 CDN 链接（http/https）
                  if (href.startsWith('http://') || href.startsWith('https://')) {
                    return match;
                  }

                  // 获取相对路径的 CSS 文件
                  const cssPath = path.resolve(outputPath, href.replace(/^\//, ''));

                  if (fs.existsSync(cssPath)) {
                    const cssContent = fs.readFileSync(cssPath, 'utf-8');
                    return `<style>${cssContent}</style>`;
                  }

                  return match;
                }
              );

              // 写回文件
              fs.writeFileSync(htmlPath, html, 'utf-8');
            });

            // 删除已内联的 .js 和 .js.map 文件
            const allFiles = fs.readdirSync(outputPath);
            allFiles.forEach((file) => {
              if (file.endsWith('.js') || file.endsWith('.js.map')) {
                const filePath = path.resolve(outputPath, file);
                try {
                  fs.unlinkSync(filePath);
                  console.log(`Deleted inlined file: ${file}`);
                } catch (error) {
                  console.warn(`Failed to delete file ${file}:`, error);
                }
              }
            });

            // 复制 src/data 目录下的所有 .json 文件到 dist 目录
            const distDataDir = path.resolve(outputPath, 'data');
            
            if (fs.existsSync(dataDir)) {
              // 创建 dist/data 目录（如果不存在）
              if (!fs.existsSync(distDataDir)) {
                fs.mkdirSync(distDataDir, { recursive: true });
              }

              // 读取 src/data 目录下的所有文件
              const dataFiles = fs.readdirSync(dataDir);
              
              dataFiles.forEach((file) => {
                if (file.endsWith('.json')) {
                  const srcFilePath = path.resolve(dataDir, file);
                  const distFilePath = path.resolve(distDataDir, file);
                  
                  try {
                    fs.copyFileSync(srcFilePath, distFilePath);
                    console.log(`Copied JSON file: ${file} to dist/data/`);
                  } catch (error) {
                    console.warn(`Failed to copy JSON file ${file}:`, error);
                  }
                }
              });
            } else {
              console.log(`Data directory not found: ${dataDir}, skipping JSON copy`);
            }
          } catch (error) {
            console.error('InlineAssetsPlugin error:', error);
          }
          callback();
        }, 100);
      }
    );
  }
}

export default defineConfig({
  // 遇错即停，不在运行时才暴露问题
  bail: true,
  // 输出完整错误信息，便于在编译阶段定位
  stats: {
    preset: 'errors-warnings',
    errorDetails: true,
    moduleTrace: true,
  },
  entry,
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: isDev ? '[name].js' : '[name].[contenthash].js',
    clean: true,
  },
  resolve: {
    extensions: ['.ts', '.tsx', '.js', '.jsx', '.json'],
    alias: {
      '@': path.resolve(__dirname, 'src'),
    },
  },
  externals: {
    // 将 React 和 ReactDOM 标记为外部依赖，使用 CDN
    react: 'React',
    'react-dom': 'ReactDOM',
    // // react/jsx-dev-runtime 使用自定义模块提供（通过 ProvidePlugin）
    // 'react/jsx-runtime': {
    //   commonjs: 'React',
    //   commonjs2: 'React',
    //   amd: 'React',
    //   root: 'React',
    // },
  },
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: [
          {
            loader: 'builtin:swc-loader',
            options: {
              jsc: {
                parser: {
                  syntax: 'typescript',
                  tsx: true,
                  decorators: false,
                },
                transform: {
                  react: {
                    runtime: 'automatic',
                    development: true, // 强制保留 __source 属性（生产环境也保留）
                    refresh: false, // 不使用热更新
                  },
                },
              },
            },
          },
        ],
        type: 'javascript/auto',
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader', 'postcss-loader'],
      },
      {
        test: /\.json$/,
        type: 'json',
      },
      {
        test: /\.(png|jpe?g|gif|svg|webp)$/i,
        type: 'asset',
      },
    ],
  },
  plugins: [
    ...htmlPlugins,
    new InlineAssetsPlugin(),
    // 替换 react/jsx-dev-runtime 模块
    new rspack.NormalModuleReplacementPlugin(
      /^react\/jsx-dev-runtime$/,
      path.resolve(__dirname, 'src/core/jsx-dev-runtime.js')
    ),
    // 替换 react/jsx-runtime 模块
    new rspack.NormalModuleReplacementPlugin(
      /^react\/jsx-runtime$/,
      path.resolve(__dirname, 'src/core/jsx-dev-runtime.js')
    ),
    // 定义构建时常量，用于条件编译
    // 在生产环境且有内联数据时，移除不需要的 fetch 代码
    new rspack.DefinePlugin({
      __INLINE_DATA_AVAILABLE__: JSON.stringify(
        !isDev && fs.existsSync(path.resolve(__dirname, 'src/data/blueprint.json'))
      ),
    }),
  ],
  devServer: {
    port: 3000,
    hot: false, // 不使用热更新
    open: true,
    historyApiFallback: true,
  },
  optimization: {
    minimize: !isDev,
    splitChunks: isDev
      ? undefined
      : {
          chunks: 'all',
          cacheGroups: {
            default: false,
            vendors: false,
          },
        },
  },
});
